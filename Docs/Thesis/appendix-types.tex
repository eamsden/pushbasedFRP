\chapter{Glossary of Type System Terms}
\label{chapter:Glossary_of_Type_System_Terms}

One of the primary attractions of the Haskell language, and the reason for its
use throughout this work, is its advanced yet practical and usable type system.
This type system enables the use of compositional software design that would
be rendered infeasible without a type system to both inform and verify
composition and implementation. This glossary describes features of the type
system which may not be familiar to a general audience.

\begin{description}
\item[ADT] See {\em Algebraic Datatype}

\item[Algebraic Datatype] An Algebraic Datatype or ADT is a type whose terms
are {\em data constructors}. An ADT is defined by naming a
{\em type constructor} and its parameters (zero or more)
(as {\em type variables}), together with one or more data constructors and the
types of their members. Each data constructor takes a fixed number
(zero or more) data members, whose types are given following the constructor
name. These types are defined in terms of the type variables named as parameters
of the type constructor and any type constructors (including the type
constructor associated with the ADT) in scope in the module.

\item[Data Constructor] A Data Constructor is a component of an
Algebraic~Datatype which, when applied to values of the appropriate type, 
creates a value typed with the ADT. Data constructors are the primary element
which may be pattern matched in languages such as Haskell.

\item[Existential Type] An existential type is a means of ``hiding'' a
{\em type variable} in an {\em Algebraic Datatype} or
{\em Generalized Algebraic Datatype}. The Glasgow Haskell Compiler provides
existential types in two ways. The first is the {\tt Rank2Types} and
{\tt RankNTypes} extensions. With either of these extensions enabled,
type variables may be brought into scope for specific {\em data constructor} in
an Algebraic Datatype using the {\tt forall} keyword. Since this
type variable is not contained in the parameters of the type constructor, it
cannot be constrained by type inference. Thus, no external function can assume
anything about its type, except for equality between occurrences of the
variable, and {\em class constraints} given in the definition of the data
constructor. The other way is through Generalized Algebraic Datatypes. Any
variable occurring in the type of a data member of a data constructor of a
Generalized Algebraic Datatype, but not occurring in the type of that
constructor, is automatically existentially quantified.


\item[Type Constructor] A type constructor is a type level term which, when
applied to the proper number of types, produces a type. Type constructors,
together with {\em type variables}, form the basis of polymorphism in Haskell
and similar languages.

\item[Type Variable] A type variable is a type-level term which may be 
instantiated (by the typechecker via inference, or by the user via annotation)
with any type. Together with {\em type constructors}, type variables form the
basis of polymorphism in Haskell and similar languages.
\end{description}