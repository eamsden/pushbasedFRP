\chapter{Glossary of Type System Terms}
\label{chapter:Glossary_of_Type_System_Terms}

One of the primary attractions of the Haskell language, and the reason for its
use throughout this work, is its advanced yet practical and usable type system.
This type system enables the use of compositional software design that would
be rendered infeasible without a type system to both inform and verify
composition and implementation. This glossary describes features of the type
system which may not be familiar to a general audience.

\begin{description}
\item[ADT] See {\em Algebraic Datatype}

\item[Algebraic Datatype] An Algebraic Datatype or ADT is a type whose terms
are {\em data constructors}. An ADT is defined by naming a
{\em type constructor} and its parameters (zero or more)
(as {\em type variables}), together with one or more data constructors and the
types of their members. Each data constructor takes a fixed number
(zero or more) data members, whose types are given following the constructor
name. These types are defined in terms of the type variables named as parameters
of the type constructor and any type constructors (including the type
constructor associated with the ADT) in scope in the module.

\item[Data Constructor] A Data Constructor is a component of an
Algebraic~Datatype which, when applied to values of the appropriate type, 
creates a value typed with the ADT. Data constructors are the primary element
which may be pattern matched in languages such as Haskell.

\item[Existential Type] An existential type is a means of ``hiding'' a
{\em type variable} in an {\em Algebraic Datatype} or
{\em Generalized Algebraic Datatype}. The Glasgow Haskell Compiler provides
existential types in two ways. The first is the {\tt Rank2Types} and
{\tt RankNTypes} extensions. With either of these extensions enabled,
type variables may be brought into scope for specific {\em data constructor} in
an Algebraic Datatype using the {\tt forall} keyword. Since this
type variable is not contained in the parameters of the type constructor, it
cannot be constrained by type inference. Thus, no external function can assume
anything about its type, except for equality between occurrences of the
variable, and {\em class constraints} given in the definition of the data
constructor. The other way is through Generalized Algebraic Datatypes. Any
variable occurring in the type of a data member of a data constructor of a
Generalized Algebraic Datatype, but not occurring in the type of that
constructor, is automatically existentially quantified.

\item[Generalized Algebraic Datatype] Similar to an {\em Algebraic Datatype},
but {\em type variables} in the {\em type constructor} declaration serve merely
to denote the number of type parameters (and thus may be replaced by a
{\em kind signature}) and types are given for each {\em data constructor}. These
types must have the type constructor as their top-level term, but may fill in
the parameters of the type constructor with arbitrary types. Variables which
appear in the data member types but on in the data constructor type are
{\em existentially quantified}, and types appearing in the data constructor
type but not the data member types may be instantiated arbitrarily.

\item[Kind Signature] A means of specifying the number and kind of types which
may instantiate type variables. Type variables in Haskell are not restricted to
types, but may be instantiated by type constructors as well. The kind of a
variable restricts what it may be instantiated with. A kind signature gives
kinds to a type constructor, and thus to its parameters. Specifying the kind
of a type constructor perfectly constrains the number of parameters.

\item[Type Constructor] A type constructor is a type level term which, when
applied to the proper number of types, produces a type. Type constructors,
together with {\em type variables}, form the basis of polymorphism in Haskell
and similar languages.

\item[Type Variable] A type variable is a type-level term which may be 
instantiated (by the typechecker via inference, or by the user via annotation)
with any type. Together with {\em type constructors}, type variables form the
basis of polymorphism in Haskell and similar languages.
\end{description}