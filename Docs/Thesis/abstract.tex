Functional Reactive Programming (FRP) is a promising class of abstractions for encoding interactive and time-dependent programs in
functional languages which has proven difficult to implement efficiently. Signal-function FRP is a subclass of FRP which does not provide
direct access to the time-varying values by the programmer, but rather provides signal functions as first-class objects in the
program. FRP systems provide values defined at all points in time ({\em behaviors} or {\em signals}) and values defined
at countably many points in time ({\em events}).

All signal-function implementations of FRP to date have utilized demand-driven or ``pull-based''  evaluation for both events and signals,
producing output from the FRP system whenever the consumer of the output is ready. This greatly simplifies the implementation of signal-function
FRP systems, but leads to inefficient and wasteful evaluation of the FRP system.

In contrast, an input-driven or ``push-based'' system evaluates the network whenever new input is available. This frees the system from
evaluating the network when nothing has changed, and then only components necessary to react to the input are reevaluated.
This form of evaluation has been applied to events in standard FRP systems~\cite{Elliott2009} but not in signal-function FRP systems.

I describe the implementation of a push-based signal-function FRP system. The semantics of the system are discussed, and its performance
and expressiveness for practical examples of interactive programs are compared to existing signal-function FRP systems through the
implementation of a networking application.
