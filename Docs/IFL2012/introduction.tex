\section{Introduction}
\label{section:Introduction}

Functional Reactive Programming (FRP) is a class of systems for describing
reactive programs. Reactive programs are programs which, rather than 
\new{batch-processing inputs to produce an output,}
% taking a single input and producing a single output, 
\new{instead map time-varying inputs onto outputs.}
%% must accept multiple inputs and 
%% alter temporal behavior, including the production of multiple outputs, based
%% on these inputs.

An FRP system provides a means of manipulating {\em behaviors} and
{\em events}. 
\rn{Switched to present tense.  Don't need to add additional future or past tense...}
Behaviors are often referred to as {\em signals} in FRP literature,
but the definition is the same.  Semantically, a behavior or signal is a
function from time to a value.  
\new{Whereas an event is a ordered sequence of discrete occurrences,
  carrying both values and timestamps.}
%% An event is a discrete, possibly infinite, and 
%% time-ordered sequence of occurrences, which are times paired with values.

\rn{Looks like you should standardize early on {\bf signal} and leave
  extra occurrences of {\bf behavior} out of this intro.}


FRP systems can generally be categorized as ``classic FRP,'' 
% which corresponds to the originally described FRP system 
in which behaviors
and events are manipulated directly as first-class values,
% in the FRP system,
or {\em signal-function FRP}. 
% in which behaviors  (generally termed signals in this approach) 
\new{In signal-function FRP, the programmer cannot directly manipulate
  signals, rather, functions from input-signal to output-signal are
  the central abstraction.  Thus}
%% and events are not first-class values, but signal
%% functions are first class values. 
signal functions are time-dependent,
reactive transformers of signals, events, or combinations of signals and events.
%
FRP {\em combines} behaviors and events through the use of {\em switching}, in which
a behavior (in classic FRP) or a signal function (in signal-function FRP) is
replaced by a new behavior or signal function carried by an event occurrence.

\todo{TODO: it would be good to give SOME sense for how an FRP
  evaluation proceeds (e.g. a strawman) before getting into the next para.}

Classic FRP was first described as a system for interactive animations~\cite{Elliott1997}.
Recent work on classic FRP has focused on efficient implementation \rn{CITATION?}.  One approach to
efficiency is to separate the evaluation of behaviors and events, since suitable 
strategies give best performance in each case. Push-based evaluation evaluates a
system only when input is available, and is thus suitable for discrete inputs
such as events. Pull-based evaluation evaluates the system as quickly as
possible, polling for input, and is preferable for behaviors and signals.
The initial implementations of FRP made use of pull-based evaluation for both
behaviors and events. ``Reactive''~\cite{Elliott2009}, as well as more recent systems such as
``reactive-banana''~\cite{Apfelmus}, make use of push-based evaluation for
events and pull-based evaluation for behaviors. This is known as ``push-pull''
evaluation.


All implementations of signal-function FRP to date~\cite{Courtney2001-1,Nilsson2002,Nilsson2005,Sculthorpe2011}
have used pull-based evaluation for both signals and events. This is due to
the ease of implementation of pull-based evaluation, and because the types used for
signal functions do not permit distinguishing signals and events, or
constructing only part of the input (for instance, one event occurrence).

\rn{What does it mean to construct one event occurrence?  As opposed to?}

A recent extension of signal-function FRP called N-Ary FRP~\cite{Sculthorpe2011}
describes a method of typing signal functions which, as we will show, enables
the push-based evaluation of events in a signal-function FRP system. The notion
of signal vectors allows the representation of signal function inputs and
outputs as combinations of signals and events, rather than a single signal which
may contain multiple values, including option values for events. Signal vectors
are uninhabited types, which can be used to describe partial or full representations
of the signal function inputs and outputs.

We present TimeFlies,\footnote{The sentence ``Time flies like an arrow.'' is a 
favorite quotation of one of the author's philosophy instructors, used to
demonstrate the ambiguity of language. The origin of the quotation is unknown.}
a push-pull signal-function FRP system. We hope to demonstrate the feasibility
of such an approach to FRP, and provide a basis for further research into
efficient implementation of signal-function FRP. We also describe a powerful
evaluation interface for TimeFlies, which permits us to use TimeFlies to
describe applications which make use of multiple and differing IO libraries.

\rn{Need a concrete contributions list.   ``The first system to apply
  push-pull implementation strategies to signal-function FRP'', etc.
  It doesn't hurt for it to be bulletted.}

Section~\ref{section:System_Design_and_Interface} describes design choices for the system,
and provides an overview of the interface. Section~\ref{section:Implementation}
describes how the system is implemented, and how the separation of evaluation
between events and signals is achieved. Section~\ref{section:Discussion} is a
discussion of the \textred{usefulness} \rn{more specific?} of our implementation. 
Section~\ref{section:Ongoing_and_Further_Work} describes the current and future
work on this system. Section~\ref{section:Related_Work} gives an overview of
related efforts. Section~\ref{section:Conclusion} concludes.

