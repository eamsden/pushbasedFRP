\section{Introduction}
\label{section:Introduction}

Functional Reactive Programming (FRP) is a class of systems for describing
interactive programs. These are programs which, rather than batch-processing
inputs to produce an output, instead map time-varying inputs onto outputs.


An FRP system provides a means of manipulating {\em behaviors} and
{\em events}. Behaviors are often referred to as {\em signals} in FRP literature,
but the definition is the same.  Semantically, a behavior or signal is a
function from time to a value. An event is a ordered sequence of discrete
occurrences, carrying both values and timestamps.

FRP systems can generally be categorized as ``classic FRP,'' in which behaviors
and events are manipulated directly as first-class values,
or {\em signal-function FRP}. In signal-function FRP, the programmer cannot
directly manipulate signals, rather, the programmer manipulates time-dependent,
reactive transformers of signals, events, or combinations of signals and events.

FRP combines behaviors and events through the use of {\em switching}, in which
a behavior (in classic FRP) or a signal function (in signal-function FRP) is
replaced by a new behavior or signal function carried by an event occurrence.

An FRP program is generally evaluated by supplying a behavior or signal function
to an evaluation function, which supplies input (in the case of a signal
function) and actuates its outputs as they are produced. For instance, if a
video game is implemented in a signal-function FRP system, the evaluation
function is responsible for obtaining keyboard and mouse inputs and supplying
them to the signal function, and actuating the outputs of the signal function
as graphics on the monitor and sound through the speakers.

Classic FRP was first described as a system for interactive animations~\cite{Elliott1997}.
Recent work on classic FRP has focused on efficient implementation. One approach
to efficiency is to separate the evaluation of behaviors and events, since
suitable strategies give best performance in each case. Push-based evaluation
evaluates a system only when input is available, and is thus suitable for
discrete inputs such as events. Pull-based evaluation evaluates the system as
quickly as possible, polling for input, and is preferable for behaviors and
signals. The initial implementations of FRP made use of pull-based evaluation
for both behaviors and events. ``Reactive''~\cite{Elliott2009}, as well as more
recent systems such as ``reactive-banana''~\cite{Apfelmus}, make use of
push-based evaluation for events and pull-based evaluation for behaviors. This
is known as ``push-pull'' evaluation.

Almost all implementations of signal-function FRP to date~\cite{Courtney2001-1,Nilsson2002,Nilsson2005,Sculthorpe2011}
have used pull-based evaluation for both signals and events. This is due to the
ease of implementation of pull-based evaluation, and because the types used for
signal functions do not permit distinguishing signals and events, or
constructing only part of the input (for instance, an occurrence on one of the
event inputs). One signal function system~\cite{Jeffrey2012} does permit the
user to push {\em segments} of signals, but, like the others, does not
distinguish events in a way that permits them to be separately pushed.

A recent extension of signal-function FRP called N-Ary FRP~\cite{Sculthorpe2011}
describes a method of typing signal functions which, as we will show, enables
the push-based evaluation of events in a signal-function FRP system. The notion
of signal vectors allows the representation of signal function inputs and
outputs as combinations of signals and events, rather than a single signal which
may contain multiple values, including option values for events. Signal vectors
are uninhabited types, which can be used to describe partial or full representations
of the signal function inputs and outputs.

TimeFlies,\footnote{The sentence ``Time flies like an arrow.'' is a 
favorite quotation of one of the author's philosophy instructors, used to
demonstrate the ambiguity of language. The origin of the quotation is unknown.}
is a push-pull signal-function FRP system, implemented in the Haskell
programming language. We show that typing signal-function FRP with signal
vectors allows push-pull evaluation of signal functions. We demonstrate an
evaluation interface that allows the user of TimeFlies to take advantage of this
behavior in interfacing TimeFlies to a wide range of IO systems. Finally, we
give benchmark results which demonstrate that the push-pull evaluation strategy
makes TimeFlies more efficient than the current pull-based implementation of
signal-function FRP.

Section~\ref{section:System_Design_and_Interface} describes design choices for the system,
and provides an overview of the interface. Section~\ref{section:Implementation}
describes how the system is implemented, and how the separation of evaluation
between events and signals is achieved. Section~\ref{section:Discussion} is a
discussion of the performance of our implementation in the implementation of a
network application. Section~\ref{section:Related_Work} gives an overview of
related efforts. Section~\ref{section:Conclusion} concludes.

