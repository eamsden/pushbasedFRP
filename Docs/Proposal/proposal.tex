\documentclass[11pt]{artikel3}
\usepackage{fullpage, setspace, graphicx}
\usepackage[margin=1in]{geometry}
\usepackage{times}

\title{RIT Department of Computer Science\\MSc Thesis Proposal:\\\emph{Implementation of a Push-Based Signal-Function FRP System and Evaluation Interface}}
\author{Edward Amsden}
\date{\today}

\begin{document}
\maketitle

\section{Background}
Functional Reactive Programming (FRP) is a family of languages for
declaratively specifying reactive systems. Functional reactive
programming enables declarative specification of reactive systems with
the advantages of functional languages, including ease of reasoning,
higher-order constructs, and composability. FRP includes the concepts
of {\em signals} (or {\em behaviors}) which are continuous, time
varying values, and {\em events} which are discrete time-value pairs.

FRP is split into two distinct families. Classic FRP (CFRP) presents
behaviors and events as first class values to be manipulated by
language constructs. While this approach enables simple reasoning
about programs, most implementations admit space and time leaks. In
addition, it is not clear how external inputs can be provided to
CFRP programs unless primitive behaviors or events for these
inputs are supplied by the library author.

In contrast, Signal Function FRP presents {\em signal functions} as
first class values. In Signal Function FRP (SF-FRP), a program is a
signal function with explicit input, which is supplied by an
evaluation function. SF-FRP programs enforce causality by not
permitting a signal function to evaluate another signal function
directly, thus, they eliminate a large class of time and space leaks.

The problem of efficient evaluation of FRP programs has been
extensively studied. {\em Push-based} evaluation has been demonstrated
for CFRP programs, enabling efficient evaluation of events. A system
enabling the type-safe addition of ad-hoc dynamic optimizations for
Yampa, an implementation of SF-FRP, has also been
demonstrated. However, all documented implementations of SF-FRP are
{\em pull-based}, meaning that they are re-evaluated whenever output
is requested and must synchronize inputs and outputs.

\section{Problem Statement}
The SF-FRP model seems inherently pull-based. However, a push-based
FRP model would eliminate sampling latency on events, as well as
wasted computation when non-occurrences of events are sampled. This
would result in much more responsive and less computationally taxing
SF-FRP systems. However, this requires a method of distinguishing
events from signals in the type systems while still permitting them to
influence each other (i.e. permitting signal functions to take
heterogenous collections of signals and events as both input and output).

The evaluation interface for SF-FRP systems is left unspecified in
literature. In practice, it has been implemented as an infinite loop
which runs a provided IO action to acquire input, and then provides
the signal function output to another IO action. This approach does
not lend itself to push-based evaluation, is not composable, is
awkward to supply input to, and permits the programmer no control
over the ``sampling rate'' of the FRP program. The structure of the
evaluation interface is essential both for the ease of efficiently
communicating input and output between the SF-FRP program and the
outside world, and for enabling push-based evaluation of the SF-FRP
program by permitting the supply of input to be decoupled from the
consuming of output.

\section{Proposed Research}

\section{Research Procedure}

\section{Summary}

\bibliography{proposal}{}
\bibliographystyle{acm}

\end{document}
